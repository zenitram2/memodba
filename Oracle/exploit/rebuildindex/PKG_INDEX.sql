


CREATE OR REPLACE PACKAGE perfstat.PKG_INDEX AUTHID CURRENT_USER IS
vMinBlks     CONSTANT POSITIVE := 1000;
vScaleFactor CONSTANT NUMBER := 0.6;
vTargetUse   CONSTANT POSITIVE := 90;  -- equates to pctfree 10  
vHistRet     CONSTANT POSITIVE := 10;  -- (#) records to keep in index_hist
 PROCEDURE HELP;
 FUNCTION VERSION RETURN VARCHAR;
 procedure diag;
 procedure inspect_all;
 procedure rebuild;
 procedure inspect_schema (aSchemaName IN VARCHAR2);
 procedure inspect_index (aIndexOwner IN VARCHAR2, aIndexName IN VARCHAR2, aTableOwner IN VARCHAR2, aTableName IN VARCHAR2, aLeafBlocks IN NUMBER);
 procedure report_monitoring;
 procedure report_monitoring_detail;
 procedure monitoring (aSchemaName IN VARCHAR2);
 procedure nomonitoring (aSchemaName IN VARCHAR2);
 
END PKG_INDEX;
/

CREATE OR REPLACE PACKAGE BODY perfstat.PKG_INDEX IS
---------------------------------------------------------------------------------------------------------------------
function version Return Varchar	is Begin Return( 'v1.1' ); End;

procedure printout(p_clob in out nocopy clob) is
      offset number ;
      amount number;
      len    number;
      lc_buffer varchar2(32767);
      i pls_integer;
    begin
      offset  := 1;
      amount  := 32767;
      len     := dbms_lob.getlength(p_clob);      
      i  := 1;      
      if ( dbms_lob.isopen(p_clob) != 1 ) then
        dbms_lob.open(p_clob, 0);
      end if;
      amount := instr(p_clob, chr(10), offset);
      while ( offset < len )
      loop
        dbms_lob.read(p_clob, amount, offset, lc_buffer);
        DBMS_OUTPUT.PUT('|                              |                              |                    |                                      |                                      |'||lc_buffer);
       offset := offset + amount;
       i := i + 1;
      end loop; 
          if ( dbms_lob.isopen(p_clob) = 1 ) then
        dbms_lob.close(p_clob);
      end if; 
    exception
      when others then
         dbms_output.put_line('Error : '||sqlerrm);
    end printout;

procedure purge_indexlog
is
	begin
		execute immediate 'truncate table perfstat.index_log';
end purge_indexlog;

---------------------------------------------------------------------------------------------------------------------
procedure HELP
IS	wDATEDEB	VARCHAR( 15 );	wDATEFIN	VARCHAR( 15 );	wVERSION	VARCHAR( 15 );	wDateLimit	DATE;
BEGIN	dbms_output.enable( 1000000 );
	--------------------------------------------------------
	SELECT TO_CHAR( trunc( sysdate   ), 'YYYYMMDD' ) INTO wDATEDEB FROM DUAL;
	SELECT TO_CHAR( trunc( sysdate+1 ), 'YYYYMMDD' ) INTO wDATEFIN FROM DUAL;
	wDATEDEB := '''' || wDATEDEB || '''';	wDATEFIN := '''' || wDATEFIN || '''';
	SELECT PERFSTAT.PKG_INDEX.Version INTO wVERSION FROM DUAL;
	--------------------------------------------------------
dbms_output.put_line( 
    '     /--------------------------------------------------------------------------------------------------------------------------+' );
dbms_output.put_line( wVERSION || '/ '  || RPAD( ' ' , 120 ) || '  |'  );
dbms_output.put_line( '___/  '  || RPAD( '       Package de gestion des index  (' || wVERSION || ')' , 120 ) || '  |'  );
dbms_output.put_line( '| /   '  || RPAD( '       Rappel des fonctionnalites de l''outil et exemples associes'  , 120 ) || '  |'  );
dbms_output.put_line( '|/    '  || RPAD( ' ' , 120 ) || '  |'  );
--dbms_output.put_line( 'Report : Module Tuning  (' || wVERSION || ')'  );
--dbms_output.put_line('Rappel des fonctionnalites de l''outil et exemple associe' );
dbms_output.put_line(
    '+----------+--------------------------------------------------------------------------------------------------------------------+' );
dbms_output.put_line('|   DIAG   |  BILAN DE SANTE AUTOMATIQUE   '  || RPAD( ' ' , 83 ) || '  |'  );
dbms_output.put_line('|          |  exec perfstat.PKG_INDEX.DIAG(); '  || RPAD( ' ' , 80 ) || '  |'  );
dbms_output.put_line(
    '+----------+--------------------------------------------------------------------------------------------------------------------+' );

-- dbms_output.put_line(
	-- '| RUBRIQUE |  COMPOSITION DETAILLEE DES TEMPS DE SERVICE  '  || RPAD( ' ' , 68 ) || '  |'  );
	-- dbms_output.put_line(	
	-- '|          |  exec perfstat.PKG_INDEX.Rubrique ( ' || wDATEDEB || ', ' || wDATEFIN ||	', ''CSV'', ''YYYYMMDD HH24:MI'', ''Y'' )                       |' );
	-- dbms_output.put_line(
	-- '+----------+--------------------------------------------------------------------------------------------------------------------+' ); 
	dbms_output.put_line(
	'| REBUILD  |  INSPECTION DES OBJECTS PAR INSTANCE '  || RPAD( ' ' , 76 ) || '  |'  );
	dbms_output.put_line(
	'|          |  exec perfstat.PKG_INDEX.inspect_all; '  || RPAD( ' ' , 75 ) || '  |'  );
	dbms_output.put_line(
	'|          +--------------------------------------------------------------------------------------------------------------------+' );	
	dbms_output.put_line(
	'|          |  INSPECTION DES OBJECTS PAR SCHEMA '  || RPAD( ' ' , 78 ) || '  |'  );
	dbms_output.put_line(
	'|          |  exec perfstat.PKG_INDEX.inspect_schema(''SchemaName'');'  || RPAD( ' ' , 59 ) || '  |'  );
	dbms_output.put_line(
	'|          +--------------------------------------------------------------------------------------------------------------------+' );
	dbms_output.put_line(
	'|          |  INSPECTION DES OBJECTS PAR INDEX '  || RPAD( ' ' , 79 ) || '  |'  );
	dbms_output.put_line(	
	'|          |  exec perfstat.PKG_INDEX.inspect_index(''aIndexOwner'', ''aIndexName'', ''aTableOwner'', ''aTableName'', ''aLeafBlocks'' );  |' );
	dbms_output.put_line(
	'+----------+--------------------------------------------------------------------------------------------------------------------+' );  	
	
	dbms_output.put_line(
	'|MONITORING|  ACTIVATION DU MONITORING DES INDEX '  || RPAD( ' ' , 77 ) || '  |'  );
	dbms_output.put_line(
	'|          |  exec perfstat.PKG_INDEX.monitoring(''SchemaName''); '  || RPAD( ' ' , 62 ) || '  |'  );
	dbms_output.put_line(
	'|          +--------------------------------------------------------------------------------------------------------------------+' );	
	dbms_output.put_line(
	'|          |  DESACTIVATION DU MONITORING DES INDEX '  || RPAD( ' ' , 74 ) || '  |'  );
	dbms_output.put_line(
	'|          |  exec perfstat.PKG_INDEX.nomonitoring(''SchemaName'');'  || RPAD( ' ' , 61 ) || '  |'  );
	dbms_output.put_line(
	'|          +--------------------------------------------------------------------------------------------------------------------+' );
	dbms_output.put_line(
	'|          |  RAPPORT UTILISATION PAR SCHEMA '  || RPAD( ' ' , 81 ) || '  |'  );
	dbms_output.put_line(	
	'|          |  exec perfstat.PKG_INDEX.report_monitoring;'  || RPAD( ' ' , 70 ) || '  |'  );	
	dbms_output.put_line(
	'|          +--------------------------------------------------------------------------------------------------------------------+' );
	dbms_output.put_line(
	'|          |  RAPPORT UTILISATION DETAILLEE '  || RPAD( ' ' , 82 ) || '  |'  );
	dbms_output.put_line(	
	'|          |  exec perfstat.PKG_INDEX.report_monitoring_detail;'  || RPAD( ' ' , 63 ) || '  |'  );
	dbms_output.put_line(
	'+----------+--------------------------------------------------------------------------------------------------------------------+' );  	
	
END help;



---------------------------------------------------------------------------------------------------------------------
procedure report_monitoring IS

 begin
 
 
 dbms_output.put_line( '+------------------------------+------------------------------+----------+------------------+-------------------+-------------------+');
 dbms_output.put_line( '|           OWNER              |          MONITORING          |   USED   |        NB        |  START_MONITORING |   END_MONITORING  |');
 dbms_output.put_line( '+------------------------------+------------------------------+----------+------------------+-------------------+-------------------+');
 
  
 FOR s IN ( select  OWNER,
 DECODE(GROUPING(MONITORING),1,'ALL',MONITORING) as MONITORING, 
DECODE(GROUPING(USED),1,'ALL',USED) as USED,
count(INDEX_NAME) NB,
nvl(min(START_MONITORING),' ') START_MONITORING,nvl(max(END_MONITORING),' ') END_MONITORING
from sys.DBA_OBJECT_USAGE 
GROUP BY GROUPING SETS (
            (OWNER,MONITORING),
            (OWNER,USED))
order by OWNER, USED ,MONITORING) LOOP   
	
		
	dbms_output.put_line( '|' || s.owner    || RPAD( ' ' , 30 - length(s.owner) )     
	||'|'||    s.MONITORING || RPAD( ' ' , 30 - length(s.MONITORING) )
	||'|'||    s.USED || RPAD( ' ' , 10 - length(s.USED) )  
	||'|'||  s.NB  || RPAD( ' ' , 18 - length(s.NB) )   
	||'|'||  s.START_MONITORING  || RPAD( ' ' , 19 - length(s.START_MONITORING) )   
	||'|'||  s.END_MONITORING || RPAD( ' ' , 19 - length(s.END_MONITORING))     ||'|');		
	
  END LOOP;
 
  dbms_output.put_line( '+------------------------------+------------------------------+----------+------------------+-------------------+-------------------+');
   
   

end report_monitoring;

---------------------------------------------------------------------------------------------------------------------
procedure report_monitoring_detail IS

 begin
 
 
 dbms_output.put_line( '+------------------------------+------------------------------+----------+------------------------------+-------------------+-------------------+');
 dbms_output.put_line( '|           OWNER              |          MONITORING          |   USED   |          INDEX_NAME          |  START_MONITORING |   END_MONITORING  |');
 dbms_output.put_line( '+------------------------------+------------------------------+----------+------------------------------+-------------------+-------------------+');
 
  
 FOR s IN (  select  OWNER,MONITORING,USED,INDEX_NAME,nvl(START_MONITORING,' ') START_MONITORING,nvl(END_MONITORING,' ') END_MONITORING
from sys.DBA_OBJECT_USAGE 
order by OWNER, USED ,MONITORING) LOOP   
	
		
	dbms_output.put_line( '|' || s.owner    || RPAD( ' ' , 30 - length(s.owner) )   
    ||'|'||  s.MONITORING || RPAD( ' ' , 30 - length(s.MONITORING) )	
	||'|'||  s.USED || RPAD( ' ' , 10 - length(s.USED) )  
	||'|'||  s.INDEX_NAME  || RPAD( ' ' , 30 - length(s.INDEX_NAME) )   
	||'|'||  s.START_MONITORING  || RPAD( ' ' , 19 - length(s.START_MONITORING) )   
	||'|'||  s.END_MONITORING || RPAD( ' ' , 19 - length(s.END_MONITORING) )     ||'|');		
	
  END LOOP;
 
  dbms_output.put_line( '+------------------------------+------------------------------+----------+------------------------------+-------------------+-------------------+');
   
   

end report_monitoring_detail;

---------------------------------------------------------------------------------------------------------------------
procedure report IS
nbtest number;
 begin
 select count(*) into nbtest   from perfstat.index_log;
 if nbtest > 0 then 
 dbms_output.put_line( '+------------------------------+------------------------------+--------------------+--------------------------------------+--------------------------------------+');
 dbms_output.put_line( '|           OWNER              |          INDEX_NAME          |   LAST_INSPECTED   |              LEAF_BLOCKS             |            TARGET_SIZE               |');
 dbms_output.put_line( '+------------------------------+------------------------------+--------------------+--------------------------------------+--------------------------------------+');
  end if;
 FOR s IN (select owner, index_name, last_inspected, leaf_blocks, target_size  from perfstat.index_log) LOOP   
	
		
	dbms_output.put_line( '|' || s.owner    || RPAD( ' ' , 30 - length(s.owner) )     ||'|'||    s.index_name || RPAD( ' ' , 30 - length(s.index_name) )  
	||'|'||  s.last_inspected  || RPAD( ' ' , 20 - length(s.last_inspected) )   
	||'|'||  s.leaf_blocks  || RPAD( ' ' , 38 - length(s.leaf_blocks) )   
	||'|'||  s.target_size || RPAD( ' ' , 38 - length(s.leaf_blocks) )     ||'|');		
	
  END LOOP;
  if nbtest > 0 then
  dbms_output.put_line( '+------------------------------+------------------------------+--------------------+--------------------------------------+--------------------------------------+');
  else
  dbms_output.put_line( '+------------------------------+');
  dbms_output.put_line( '|   Aucun index problématique |');
  dbms_output.put_line( '+------------------------------+');
   end if;
   
   

end report;




procedure report_detail IS
 begin
 dbms_output.put_line( '+---------------------------------------------------------------------+------------------------------+------------------------------+--------------------+--------------------------------------+--------------------------------------+');
 dbms_output.put_line( '|                           IDX_LAYOUT                                |           OWNER              |          INDEX_NAME          |   LAST_INSPECTED   |              LEAF_BLOCKS             |            TARGET_SIZE                ');		
 dbms_output.put_line( '+---------------------------------------------------------------------+------------------------------+------------------------------+--------------------+--------------------------------------+--------------------------------------+');
 FOR s IN (select owner, index_name, last_inspected, leaf_blocks, target_size,IDX_LAYOUT  from perfstat.index_log) LOOP   
	
		
	dbms_output.put_line( '|' ||s.IDX_LAYOUT || RPAD( ' ' , 70 - length(s.IDX_LAYOUT) )	||'|' || s.owner    || RPAD( ' ' , 30 - length(s.owner) )     ||'|'||    s.index_name || RPAD( ' ' , 30 - length(s.index_name) )  
	||'|'||  s.last_inspected  || RPAD( ' ' , 20 - length(s.last_inspected) )   
	||'|'||  s.leaf_blocks  || RPAD( ' ' , 38 - length(s.leaf_blocks) )   
	||'|'||  s.target_size || RPAD( ' ' , 38 - length(s.target_size) ));   
	--  printout(s.IDX_LAYOUT) ;
   --dbms_output.put ( RPAD( ' ' , 70 - length(s.IDX_LAYOUT) )	||'|');		
	
  END LOOP;
  dbms_output.put_line( '+------------------------------+------------------------------+--------------------+--------------------------------------+--------------------------------------+');

end report_detail;
---------------------------------------------------------------------------------------------------------------------
procedure rebuild_proc is
		wDATEDEB	VARCHAR( 19 );	
		wDATEFIN	VARCHAR( 19 );
		v_timediff BINARY_DOUBLE; -- time in 100th of a second
        v_start_time PLS_INTEGER; 
BEGIN	dbms_output.enable( 100000000 );
	--------------------------------------------------------
	SELECT TO_CHAR(  sysdate  , 'YYYYMMDD HH24:MI:SS' ) INTO wDATEDEB FROM DUAL;
	
	wDATEDEB := '''' || wDATEDEB || '''';	
	 
	dbms_output.put_line( wDATEDEB || ' Début de reconstruction des index');	
	 FOR s IN (select owner, index_name  from perfstat.index_log) LOOP   
		
		v_start_time := dbms_utility.get_time();		
		execute immediate 'alter index ' || s.owner || '.' || s.index_name || ' rebuild online';
		v_timediff := dbms_utility.get_time() - v_start_time;
		dbms_output.put_line(RPAD( ' ' , 15 ) || 'Traitement de '  ||s.owner || '.' || s.index_name || ' (' || v_timediff/100 || 'sec)'); 	
	END LOOP;
	SELECT TO_CHAR(  sysdate, 'YYYYMMDD HH24:MI:SS' ) INTO wDATEFIN FROM DUAL;
	wDATEFIN := '''' || wDATEFIN || '''';
	dbms_output.put_line( wDATEFIN || ' Fin de reconstruction des index');	
	
end rebuild_proc;
---------------------------------------------------------------------------------------------------------------------



procedure diag IS
 begin
	dbms_output.enable( 100000000 );
	purge_indexlog();
	inspect_all();
	report();
end diag;


---------------------------------------------------------------------------------------------------------------------
procedure rebuild IS
 begin	
	purge_indexlog();
	inspect_all();
	report();
	rebuild_proc();
	diag();
end rebuild;












---------------------------------------------------------------------------------------------------------------------
procedure inspect_all IS
 begin
 FOR s IN (select distinct owner from dba_indexes   
           where owner not in ('SYS','SYSMAN','SYSTEM','DBSNMP','PERFSTAT','CTXSYS','APEX_030200','APPQOSSYS','CTXSYS','EXFSYS','FLOWS_FILES','MDSYS','OLAPSYS','ORDDATA','ORDSYS','OUTLN','OWBSYS','WMSYS','XDB')              
           order by owner) LOOP   
   inspect_schema (s.owner);
  END LOOP;
 commit;
end inspect_all;


---------------------------------------------------------------------------------------------------------------------
procedure monitoring (aSchemaName IN VARCHAR2) IS

 CURSOR SQL_MON(vschema VARCHAR2) IS 
  with listing_index as (
   select owner,index_name 
      from All_Indexes where owner=vschema
      )
         select 'alter index    "' || owner || '"."' || index_name ||  '" monitoring usage ' mon
         from listing_index 
         ;
sRequete                                Varchar2(32000);

 begin
 
	sRequete := '';
	DBMS_OUTPUT.PUT_LINE('Ajout du monitoring des index');
 
 OPEN SQL_MON(aSchemaName);
  
	LOOP
		FETCH SQL_MON INTO sRequete;
		EXIT WHEN SQL_MON%NOTFOUND;    
      
	  execute immediate sRequete;
      
	END LOOP;
	CLOSE SQL_MON;
end monitoring;
---------------------------------------------------------------------------------------------------------------------
procedure nomonitoring (aSchemaName IN VARCHAR2) IS

  CURSOR SQL_NOMON(vschema VARCHAR2) IS 
  with listing_index as (
   select owner,index_name 
      from All_Indexes where owner=vschema
      )
         select 'alter index    "' || owner || '"."' || index_name ||  '" nomonitoring usage ' mon
         from listing_index 
         ;
sRequete                                Varchar2(32000);

 begin
 
	sRequete := '';
	DBMS_OUTPUT.PUT_LINE('Suppression du monitoring des index');
 
 OPEN SQL_NOMON(aSchemaName);
  
	LOOP
		FETCH SQL_NOMON INTO sRequete;
		EXIT WHEN SQL_NOMON%NOTFOUND;    
      
	  execute immediate sRequete;
      
	END LOOP;
	CLOSE SQL_NOMON;
end nomonitoring;

---------------------------------------------------------------------------------------------------------------------
procedure inspect_schema (aSchemaName IN VARCHAR2) IS
 begin
 FOR r IN (select table_owner, table_name, owner index_owner, index_name, leaf_blocks
           from dba_indexes  
           where owner = upper(aSchemaname)
             and index_type in ('NORMAL','NORMAL/REV','FUNCTION-BASED NORMAL')
             and partitioned = 'NO'  
             and temporary = 'N'  
             and dropped = 'NO'  
             and status = 'VALID'  
             and last_analyzed is not null  
           order by owner, table_name, index_name) LOOP

   IF r.leaf_blocks > vMinBlks THEN
   inspect_index (r.index_owner, r.index_name, r.table_owner, r.table_name, r.leaf_blocks);
   END IF;
  END LOOP;
 commit;
end inspect_schema;
procedure inspect_index (aIndexOwner IN VARCHAR2, aIndexName IN VARCHAR2, aTableOwner IN VARCHAR2, aTableName IN VARCHAR2, aLeafBlocks IN NUMBER) IS
 vLeafEstimate number;  
 vBlockSize    number;
 vOverhead     number := 192; -- leaf block "lost" space in index_stats
 vIdxObjID     number;
 vSqlStr       VARCHAR2(4000);
 vIndxLyt      CLOB;
 vCnt          number := 0;
  TYPE IdxRec IS RECORD (rows_per_block number, cnt_blocks number);
  TYPE IdxTab IS TABLE OF IdxRec;
  l_data IdxTab;
begin  
  select a.block_size into vBlockSize from dba_tablespaces a,dba_indexes b where b.index_name=aIndexName and b.owner=aIndexOwner and a.tablespacE_name=b.tablespace_name;
 select round (100 / vTargetUse *       -- assumed packing efficiency
              (ind.num_rows * (tab.rowid_length + ind.uniq_ind + 4) + sum((tc.avg_col_len) * (tab.num_rows) )  -- column data bytes  
              ) / (vBlockSize - vOverhead)  
              ) index_leaf_estimate  
   into vLeafEstimate  
 from (select  /*+ no_merge */ table_name, num_rows, decode(partitioned,'YES',10,6) rowid_length  
       from dba_tables
       where table_name  = aTableName  
         and owner       = aTableOwner) tab,  
      (select  /*+ no_merge */ index_name, index_type, num_rows, decode(uniqueness,'UNIQUE',0,1) uniq_ind  
       from dba_indexes  
       where table_owner = aTableOwner  
         and table_name  = aTableName  
         and owner       = aIndexOwner  
         and index_name  = aIndexName) ind,  
      (select  /*+ no_merge */ column_name  
       from dba_ind_columns  
       where table_owner = aTableOwner  
         and table_name  = aTableName
         and index_owner = aIndexOwner   
         and index_name  = aIndexName) ic,  
      (select  /*+ no_merge */ column_name, avg_col_len  
       from dba_tab_cols  
       where owner = aTableOwner  
         and table_name  = aTableName) tc  
 where tc.column_name = ic.column_name  
 group by ind.num_rows, ind.uniq_ind, tab.rowid_length;

 IF vLeafEstimate < vScaleFactor * aLeafBlocks THEN
  select object_id into vIdxObjID
  from dba_objects  
  where owner = aIndexOwner
    and object_name = aIndexName;
   vSqlStr := 'SELECT rows_per_block, count(*) blocks FROM (SELECT /*+ cursor_sharing_exact ' ||
             'dynamic_sampling(0) no_monitoring no_expand index_ffs(' || aTableName ||
             ',' || aIndexName || ') noparallel_index(' || aTableName ||
             ',' || aIndexName || ') */ sys_op_lbid(' || vIdxObjID ||
             ', ''L'', ' || aTableName || '.rowid) block_id, ' ||
             'COUNT(*) rows_per_block FROM ' || aTableOwner || '.' || aTableName || ' GROUP BY sys_op_lbid(' ||
             vIdxObjID || ', ''L'', ' || aTableName || '.rowid)) group by rows_per_block order by rows_per_block';
   execute immediate vSqlStr BULK COLLECT INTO l_data;
  vIndxLyt := '';

   FOR i IN l_data.FIRST..l_data.LAST LOOP
    vIndxLyt := vIndxLyt || l_data(i).rows_per_block || ' - ' || l_data(i).cnt_blocks || chr(10);
   END LOOP;

   select count(*) into vCnt from perfstat.index_log where owner = aIndexOwner and index_name = aIndexName;

   IF vCnt = 0   
    THEN insert into perfstat.index_log values (aIndexOwner, aIndexName, sysdate, aLeafBlocks, round(vLeafEstimate,2), vIndxLyt);
    ELSE vCnt := 0;

         select count(*) into vCnt from index_hist where owner = aIndexOwner and index_name = aIndexName;

         IF vCnt >= vHistRet THEN
           delete from index_hist
           where owner = aIndexOwner
             and index_name = aIndexName
             and inspected_date = (select MIN(inspected_date)
                                   from index_hist
                                   where owner = aIndexOwner
                                     and index_name = aIndexName);
         END IF;

          insert into index_hist select * from perfstat.index_log where owner = aIndexOwner and index_name = aIndexName;

         update perfstat.index_log  
         set last_inspected = sysdate,
             leaf_blocks = aLeafBlocks,
             target_size = round(vLeafEstimate,2),
             idx_layout = vIndxLyt
        where owner = aIndexOwner and index_name = aIndexName;

   END IF;
  END IF;
 END inspect_index;
 

END PKG_INDEX;
/