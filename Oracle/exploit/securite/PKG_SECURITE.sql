create or replace PACKAGE      SECU.PKG_SECURITE AS
--
-- Declarations des fonctions  procedures publiques
FUNCTION ENCRYPTETEXT (pvText IN VARCHAR2, pvPassword IN VARCHAR2) RETURN RAW;
FUNCTION ENCRYPTENUMBER (pnNumber IN NUMBER, pvPassword IN VARCHAR2) RETURN RAW;
FUNCTION ENCRYPTEDATE (pdDate IN Date, pvPassword IN VARCHAR2) RETURN RAW;
FUNCTION DECRYPTETEXT (prRaw IN RAW, pvPassword IN VARCHAR2) RETURN VARCHAR2;
FUNCTION DECRYPTENUMBER (prRaw IN RAW, pvPassword IN VARCHAR2) RETURN NUMBER;
FUNCTION DECRYPTEDATE (prRaw IN RAW, pvPassword IN VARCHAR2) RETURN DATE;
--FUNCTION CRYPTEPASSWORD (pvusername in VARCHAR2, pvpassword in VARCHAR2 ) RETURN RAW;
PROCEDURE KEY_TO_CHR(pvKey in varchar2);
--
--
-- ********************************************************
-- NOM              : pkg_secu.sql
-- LANGAGE          : PL/SQL
-- ********************************************************
-- AUTEUR           : MEMODBA
-- VERSION          : 1.0.1 
-- DATE DE CREATION : 07/10/2015
-- ********************************************************
-- DESCRIPTION      :
-- Cryptage et decyptage des donnees et des mots de passe
-- 
-- ********************************************************
-- *                   MODIFICATIONS                      *
-- *------------------------------------------------------*
-- * Quand    | Qui | Quoi                                *
-- *------------------------------------------------------*
-- * 07102015 | MEMODBA | Creation                            *
-- ********************************************************
--
END PKG_SECURITE;
/

create or replace PACKAGE BODY      SECU.PKG_SECURITE AS

-- Constantes Globales
FORMAT_NUMBER CONSTANT VARCHAR2(30) := 'FM9999999999999999.999999';
FORMAT_DATE CONSTANT VARCHAR2(25) := 'DD/MM/YYYY HH24:MI:SS';

-- Variables Globales
nErrNum NUMBER;

--la clef de cryptage est en code ASCII pour qu'elle soit invisible après le wrap
--mykeycrypte      raw(128) := hextoraw('3B31ABA38502D6D82B9F1A5DF74018592317638B1F5F3203CA844E582BFA9176');
mykeycrypte RAW(128) := hextoraw(CHR(51) ||CHR(66) ||CHR(51) ||CHR(49) ||
CHR(65) ||CHR(66) ||CHR(65) ||CHR(51) ||CHR(56) ||CHR(53) ||CHR(48) ||CHR(50) ||CHR(68) ||CHR(54) ||
CHR(68) ||CHR(56) ||CHR(50) ||CHR(66) ||CHR(57) ||CHR(70) ||CHR(49) ||CHR(65) ||CHR(53) ||CHR(68) ||
CHR(70) ||CHR(55) ||CHR(52) ||CHR(48) ||CHR(49) ||CHR(56) ||CHR(53) ||CHR(57) ||CHR(50) ||CHR(51) ||
CHR(49) ||CHR(55) ||CHR(54) ||CHR(51) ||CHR(56) ||CHR(66) ||CHR(49) ||CHR(70) ||CHR(53) ||CHR(70) ||
CHR(51) ||CHR(50) ||CHR(48) ||CHR(51) ||CHR(67) ||CHR(65) ||CHR(56) ||CHR(52) ||CHR(52) ||CHR(69) ||
CHR(53) ||CHR(56) ||CHR(50) ||CHR(66) ||CHR(70) ||CHR(65) ||CHR(57) ||CHR(49) ||CHR(55) ||CHR(54) );


 --le mot de passe est en code ASCII pour qu'il soit invisible après le wrap
--myPassword VARCHAR2(128) := 'H#K0MEH!#ED';
myPassword VARCHAR2(128) := CHR(72) || CHR(35) || CHR(75) ||
CHR(48) || CHR(77) || CHR(69) || CHR(72) ||
CHR(33) || CHR(35) || CHR(69) || CHR(68);

encryption_type    PLS_INTEGER := sys.DBMS_CRYPTO.ENCRYPT_AES256+ sys.DBMS_CRYPTO.CHAIN_CBC+ sys.DBMS_CRYPTO.PAD_PKCS5;

invalid EXCEPTION;

-- Fonctions  Procedures Publiques

-----------------------------------------------------------------------------------------------------
--
--    Fonction : ENCRYPTETEXT
--
--    DESCRIPTION DE LA FONCTION : Encrypte des données VARCHAR2 en format codee type RAW
--
-----------------------------------------------------------------------------------------------------

FUNCTION ENCRYPTETEXT (pvText IN VARCHAR2, pvPassword IN VARCHAR2) RETURN RAW IS

-- Constantes

-- Variables locales
plaintext varchar2(32767);
plaintext_raw raw(32767);
crypttext raw(32767);

-- Traitements
BEGIN
 -- On empeche le cryptage si le password est invalid
    if upper(pvPassword) != upper(myPassword) or pvPassword is null then
     raise invalid;
    end if;

    if pvText is null then
		return null;
    else
		plaintext := rpad(pvText,(trunc(length(pvText)/8)+1)*8, chr(0));
		plaintext_raw := utl_raw.cast_to_raw(plaintext);

		crypttext:=sys.dbms_crypto.encrypt(
			src => plaintext_raw,
			key =>   mykeycrypte,
			typ => encryption_type
		);
	end if;

RETURN crypttext;

-- Gestion des erreurs
EXCEPTION
WHEN invalid Then
RAISE_APPLICATION_ERROR (-20003, 'Mot de passe invalide');

WHEN OTHERS THEN
nErrNum := SQLCODE;
RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
RAISE_APPLICATION_ERROR (-20000, 'Impossible de crypter les donnees ' );
END ENCRYPTETEXT;

-----------------------------------------------------------------------------------------------------
--
--    Fonction : ENCRYPTENUMBER
--
--    DESCRIPTION DE LA FONCTION : Encrypte des donnees NUMBER en format code de type RAW
--
-----------------------------------------------------------------------------------------------------



FUNCTION ENCRYPTENUMBER (pnNumber IN NUMBER, pvPassword IN VARCHAR2) RETURN RAW IS

-- Constantes locales

-- Variables locales
plaintext varchar2(32767);
plaintext_raw raw(32767);
crypttext raw(32767);

-- Traitements
BEGIN
 -- On empeche le cryptage si le password est invalid
    if upper(pvPassword) != upper(myPassword) or pvPassword is null then
     raise invalid;
    end if;

    if pnNumber is null then
		return null;
    else
		-- Transformation du number en char au format 99.99
		-- Mise en forme pour que la longueur du texte soit un multiple de 8
		plaintext := rpad(to_char(pnNumber, FORMAT_NUMBER),(trunc(length(to_char(pnNumber, FORMAT_NUMBER))/8)+1)*8, chr(0));
		plaintext_raw := utl_raw.cast_to_raw(plaintext);
  
		crypttext:=dbms_crypto.encrypt(
			src => plaintext_raw,
			key =>   mykeycrypte,
			typ => encryption_type
		);
	end if;

RETURN crypttext;

-- Gestion des erreurs
EXCEPTION
WHEN invalid Then
RAISE_APPLICATION_ERROR (-20003, 'Mot de passe invalide');

WHEN OTHERS THEN
nErrNum := SQLCODE;
RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
RAISE_APPLICATION_ERROR (-20000, 'Impossible de crypter les donnees ' );

END ENCRYPTENUMBER;



-----------------------------------------------------------------------------------------------------
--
--    Fonction : ENCRYPTEDATE
--
--
--    DESCRIPTION DE LA FONCTION : Encrypte des donnees DATE en format codee type RAW
--
-----------------------------------------------------------------------------------------------------

FUNCTION ENCRYPTEDATE (pdDate IN Date, pvPassword IN VARCHAR2) RETURN RAW IS

-- Constantes locales

-- Variables locales
plaintext varchar2(32767);
plaintext_raw raw(32767);
crypttext raw(32767);

-- Traitements
BEGIN
 -- On empeche le cryptage si le password est invalid
    if upper(pvPassword) != upper(myPassword) or pvPassword is null then
     raise invalid;
    end if;

 if pdDate is null then
     return null;
    else
		-- Transformation dla date en char au format DD/MM/YYYY
		-- Mise en forme pour que la longueur du texte soit un multiple de 8
		plaintext := rpad(to_char(pdDate, FORMAT_DATE),(trunc(length(to_char(pdDate, FORMAT_DATE))/8)+1)*8, chr(0));
		plaintext_raw := utl_raw.cast_to_raw(plaintext);

		crypttext:=dbms_crypto.encrypt(
			src => plaintext_raw,
			key =>   mykeycrypte,
			typ => encryption_type
		);
	end if;

RETURN crypttext;

-- Gestion des erreurs
EXCEPTION
WHEN invalid Then
RAISE_APPLICATION_ERROR (-20003, 'Mot de passe invalide');

WHEN OTHERS THEN
nErrNum := SQLCODE;
RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
RAISE_APPLICATION_ERROR (-20000, 'Impossible de crypter les donnees ' );

END ENCRYPTEDATE;

-----------------------------------------------------------------------------------------------------
--
--    Fonction : DECRYPTETEXT
--
--    DESCRIPTION DE LA FONCTION : Decrypte des donn꦳ cod꦳ au format RAW au format VARCHAR2
--
-----------------------------------------------------------------------------------------------------

FUNCTION DECRYPTETEXT (prRaw IN RAW, pvPassword IN VARCHAR2) RETURN VARCHAR2 IS

-- Constantes locales

-- Variables locales
plaintext varchar2(32767);
plaintext_out raw(32767);

-- Traitements
BEGIN
 -- On empeche le decryptage si le password est invalid
    if upper(pvPassword) != upper(myPassword) or pvPassword is null then
		raise invalid;
    end if;

    if prRaw is null then
		return null;
    else
		-- Decrypt
		plaintext_out:=dbms_crypto.decrypt(
			src => prRaw,
			key => mykeycrypte,
			typ => encryption_type
		);
	plaintext := rtrim(utl_raw.cast_to_varchar2(plaintext_out), chr(0));
 end if;

RETURN plaintext;

-- Gestion des erreurs
EXCEPTION
WHEN invalid Then
RAISE_APPLICATION_ERROR (-20003, 'Mot de passe invalide');

WHEN OTHERS THEN
nErrNum := SQLCODE;
RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
RAISE_APPLICATION_ERROR (-20000, 'Impossible de crypter les donnees ' );

END DECRYPTETEXT;

-----------------------------------------------------------------------------------------------------
--
--    Fonction : DECRYPTENUMBER
--
--
--    DESCRIPTION DE LA FONCTION : Decrypte des donnees codees au format RAW au format NUMBER
--
-----------------------------------------------------------------------------------------------------

FUNCTION DECRYPTENUMBER (prRaw IN RAW, pvPassword IN VARCHAR2) RETURN NUMBER IS

-- Constantes locales

-- Variables locales
plaintext_out raw(32767);

-- Traitements
BEGIN
 -- On empeche le decryptage si le password est invalid
    if upper(pvPassword) != upper(myPassword) or pvPassword is null then
		raise invalid;
    end if;

    if prRaw is null then
		return null;
    else
		-- Decrypt
		plaintext_out:=dbms_crypto.decrypt(
			src => prRaw,
			key => mykeycrypte,
			typ => encryption_type
		);
	end if;

RETURN to_number(rtrim(utl_raw.cast_to_varchar2(plaintext_out), chr(0)), FORMAT_NUMBER);

-- Gestion des erreurs
EXCEPTION
WHEN invalid Then
RAISE_APPLICATION_ERROR (-20003, 'Mot de passe invalide');

WHEN OTHERS THEN
nErrNum := SQLCODE;
RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
RAISE_APPLICATION_ERROR (-20000, 'Impossible de crypter les donnees ' );

END DECRYPTENUMBER;

-----------------------------------------------------------------------------------------------------
--
--    Fonction : DECRYPTEDATE
--
--
--    DESCRIPTION DE LA FONCTION : Decrypte des donnees code au format RAW au format DATE
--
-----------------------------------------------------------------------------------------------------

FUNCTION DECRYPTEDATE (prRaw IN RAW, pvPassword IN VARCHAR2) RETURN DATE IS

-- Constantes locales

-- Variables locales
plaintext_out raw(32767);

-- Traitements
BEGIN
	-- On empeche le decryptage si le password est invalid
    if upper(pvPassword) != upper(myPassword) or pvPassword is null then
		raise invalid;
    end if;

    if prRaw is null then
		return null;
    else
		-- Decrypt
		plaintext_out:=dbms_crypto.decrypt(
			src => prRaw,
			key => mykeycrypte,
			typ => encryption_type
		);
	end if;

RETURN to_date(rtrim(utl_raw.cast_to_varchar2(plaintext_out), chr(0)), FORMAT_DATE);

-- Gestion des erreurs
EXCEPTION
	WHEN invalid Then
		RAISE_APPLICATION_ERROR (-20003, 'Mot de passe invalide');

	WHEN OTHERS THEN
		nErrNum := SQLCODE;
		RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
		RAISE_APPLICATION_ERROR (-20000, 'Impossible de crypter les donnees ' );

END DECRYPTEDATE;

-------------------------------------------------------------------------------------------------------
----
----    Fonction : CRYPTEPASSWORD
----
----
----    DESCRIPTION DE LA FONCTION : Cryptage du mot de passe
----
-------------------------------------------------------------------------------------------------------
--
--FUNCTION CRYPTEPASSWORD (pvusername in varchar2, pvpassword in varchar2 ) RETURN RAW IS
--
---- Constantes locales
--
---- Variables locales
--plaintext_out raw(32767);
--
---- Traitements
--BEGIN
--
--RETURN dbms_crypto.hash ( src => UTL_RAW.CAST_TO_RAW(chr(103) || upper(substr(pvpassword,1,2) || substr(pvusername,1,4) || pvusername || pvpassword) || chr(100)),typ => encryption_type);
--
---- Gestion des erreurs
--EXCEPTION
--WHEN OTHERS THEN
--nErrNum := SQLCODE;
--RAISE_APPLICATION_ERROR (-20002, 'Impossible de crypter le mot de passe');
--
--END CRYPTEPASSWORD;

-----------------------------------------------------------------------------------------------------
--
--    Fonction : KEY_TO_CHR
--
--
--    DESCRIPTION DE LA FONCTION : Renvoie la clef passee en parametre sous format ASCII
--
-----------------------------------------------------------------------------------------------------


PROCEDURE KEY_TO_CHR(pvKey in varchar2) is
     skey varchar2(1024):=pvKey;
     sChaine varchar2(32000);
     nValue number:=0;
     nNb number:=1;
     sChar varchar2(1):='';
     nLong number :=LENGTH(to_char(skey));     
    begin  
		WHILE (LENGTH(skey)) >0 LOOP      
          sChar:=substr(skey,1, 1);
          nValue:=to_number(ASCII(sChar)); 
          if nLong > 1 then
            sChaine:= sChaine || 'CHR(' || nValue ||') || ';
          else
           sChaine:= sChaine || 'CHR(' || nValue ||') ';
          end if;
          if nNb > 8 then            
            DBMS_OUTPUT.PUT_LINE(sChaine);
            sChaine:= '';
            nNb:=0;
          end if;          
          skey:=substr(skey,2, LENGTH(skey));
          nLong :=LENGTH(to_char(skey));
          nNb:=nNb+1;
		END LOOP;
		DBMS_OUTPUT.PUT_LINE(sChaine);
 -- Gestion des erreurs
EXCEPTION
WHEN OTHERS THEN
	nErrNum := SQLCODE;
	RAISE_APPLICATION_ERROR (-20000,  SQLERRM );
	RAISE_APPLICATION_ERROR (-20000, 'Impossible de convertir les donnees ' );
end KEY_TO_CHR;

END PKG_SECURITE;
/